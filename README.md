## Эволюционные методы проектирования программно-информационных систем

Мой вариант 4.

ОСТОРОЖНО! ГОВНОКОД! Особенно в лабах 2-4. Всё ужасно неэффективно написано и долго работает.

### 1 Лаба

В первой лабе ГА не до конца правильно реализован. Возможна преждевременная локализация решения (вырождение популяции).
Отправил как написал, пускай будет так. 

19/20

### 2 Лаба

Во 2й лабе неправильные графики (не соответствуют коду). Там не нужны 500 поколений, 50-100 должно хватить с запасом, был баг, который я поправил, но уже после засчитанной ЛР.
Графики остались старые. 

18/20

### 3 Лаба

Замечание по 3й лабе: там есть данные в виде транспонированной матрицы. Так вот, судя по всему, матрица на самом деле не транспонирована,
это обычная верхняя треугольная матрица, все строки надо просто смещать вправо до упора. Ну или можно там каким-образом это транспонирование применить, 
но я не понял как и зачем. Оптимальное решение проверяется нормально (с правильным значением) по матрице, разобранной без всякого транспонирования.

[Пример парсинга матриц разных форматов](https://github.com/pdrozdowski/TSPLib.Net/blob/master/TspLibNet/TspLibNet/Graph/EdgeWeights/MatrixBuilder.cs)

Исходные данные можно взять [здесь](https://github.com/pdrozdowski/TSPLib.Net/tree/master/TSPLIB95/tsp), 
чтобы не копировать из методички. Главное посмотреть что они совпадают с данными в ЛР.

Работает долго. Я запускал на 10000 итераций. Достичь оптимума можно если сильно повезет, наверное. У меня не получилось.

19/20

### 4 Лаба

Тут в целом меньше всего проблем было, вариант попался очень удачный. Немного нового кода, много копипаста из 2-3 лабы.
